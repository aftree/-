---
title: "虚拟化简介"
date: 2019-12-15T20:50:40+08:00
draft: true
#pre: "<b>1. </b>"
weight: 5
---

<img src="D:\Site\content\虚拟化\虚拟化简介\images\v.jpg" alt="v"  />

虚拟化的含义很广泛，将任何一种形式的资源抽象成另一种形式的技术都是虚拟化技术，比如进程的虚拟地址空间，就是把物理内存虚拟成多个内存空间（参考[这篇文章](https://zhuanlan.zhihu.com/p/66794639)）。相对于进程级的虚拟化，虚拟机是另外一个层面的虚拟化，它所抽象的是整个物理机，包括CPU、内存和I/O设备。在一台物理机上可以模拟出多台虚拟机（Virtual Machine，简称VM），每个虚拟机中都可以运行一个操作系统（OS）。提供虚拟化的平台被称为**VMM**(Virtual Machine Monitor)，在其上运行的虚拟机被称为**guest VM**（客户机）。根据VMM支持的虚拟机制的不同，guset VM的运行模式可分为完全虚拟化（Full Virtualization）和类虚拟化（Para Virtualization）。

**完全虚拟化**

如果一个基于硬件运行（native）的OS不需要修改任何代码就可以直接跑在VMM上，也就是guest OS根本感知不到自己运行在一个虚拟化环境中（可以说VMM是骗术高明的），这种就被称为“完全虚拟化”。在这种模式下，VMM需要正确处理guest所有可能的指令。

最简单直接的方法就是，VMM对guest运行过程中的每一条指令都进行解释和执行，模拟出这条指令执行的效果，这种方法既适用于和VMM相同体系结构的guest，也能用于模拟和VMM不同体系结构的guest（比如物理CPU是x86的，而guest是基于ARM的），其缺点也很明显，就是性能太差。

有一些指令是要操作特权资源的，比如修改虚拟机的运行模式或者下面物理机的状态，读写时钟或者中断寄存器，这些指令被称为敏感指令，确实不适合由guest直接来控制，然而其他的一些非敏感指令，是完全可以在物理CPU上直接执行并返回结果给guest的，VMM只需要截获并模拟guest对敏感指令的执行和对特权资源的访问就可以了，以intel的VT-x和AMD的AMD-V为代表的硬件辅助虚拟化技术，就可以帮助VMM高效地识别和截获这些敏感指令。

![img](https://pic2.zhimg.com/80/v2-ecbd64f11a4688ddfe80d2ebb0f29951_hd.jpg)

**类虚拟化**

像x86这种CISC架构的系统，指令繁杂，其中一些指令是难以虚拟化的，如果使用完全虚拟化，就需要通过二进制代码翻译（binary translation），扫描并修改guest的二进制代码，将难以虚拟化的指令转换成支持虚拟化的指令（ABI级），就像打补丁一样。如果能直接修改guest的操作系统内核代码（API级），就可以使得内核避免产生这些难以虚拟化的指令，这就是“类虚拟化”。类虚拟化技术需要修改直接基于native运行的OS代码，以便和VMM更好的配合，其好处就是guest的运行性能可以接近物理机的性能。

**主流模型**

当前主流的虚拟化技术的实现架构可分为三类：

**1. Hypervisor模型**

在hypervisor模型中，VMM是一个完备的操作系统，它除了具备传统操作系统的功能，还具备虚拟化功能。包括CPU、内存和I/O设备在内的所有物理资源都归VMM所有，因此VMM不仅要负责虚拟机环境的创建和管理，还承担着管理物理资源的责任。

![img](https://pic2.zhimg.com/80/v2-cc9349222111422eff794124d77e74a5_hd.jpg)

这种方式是比较高效的，然而I/O设备种类繁多，管理所有设备就意味着大量的驱动开发工作。在实际的产品中，厂商会根据产品定位，有选择的支持一些I/O设备，而不是对所有的I/O设备都提供支持。

**2. Host模型（宿主机）**

在host模型中，物理资源由host OS管理，host OS是传统操作系统（比如Linux），这些传统操作系统并不是为虚拟化而设计的，因此本身并不具备虚拟化功能，实际的虚拟化功能由VMM来提供。VMM作为host OS中一个独立的内核模块，通过调用host OS的服务来获得资源，实现CPU、内存和I/O设备的虚拟化。VMM创建出虚拟机之后，通常将虚拟机作为host OS的一个进程参与调度。

![img](https://pic2.zhimg.com/80/v2-b414c330f019f4c244e7d507ed1d3c7d_hd.jpg)

Host模型最大的优点就是可以充分利用现有操作系统的设备驱动程序，VMM不需要为各种I/O设备重新实现驱动，可以专注于物理资源的虚拟化；缺点在于，由于VMM是借助host OS的服务来操作硬件，而不是直接操作硬件，因此受限于host OS服务的支持，可能导致硬件利用的不充分。

从架构上看，由Qumranet公司开发的KVM（Kernel-based Virtual Machine）就是属于host模型的，kernel-based，顾名思义就是基于操作系统内核。KVM于2007年被集成到Linux内核2.6.20版本，并于2008年被Red Hat收购。随着越来越多的虚拟化功能被加入到Linux内核当中，Linux已经越来越像一个hypervisor了，从这个角度看，KVM也可以算是hypervisor模型了。

**3. 混合模型**

在混合模型中，VMM依然位于最底层，拥有所有的物理资源，但为了利用现有操作系统的I/O设备驱动程序，VMM会将大部分的I/O设备交由一个运行在特权级别的虚拟机操作系统（Service OS）来处理，自己则主要负责CPU管理和内存管理。

![img](https://pic1.zhimg.com/80/v2-4674b43099b11857af5c41f4602c6394_hd.jpg)

混合模型可以说是结合了上述两种模型的优点，既不需要另外开发I/O设备驱动程序，又可以通过直接控制CPU和内存实现对这些物理资源的充分利用，以提高效率。但它也是存在缺点的，当来自guest OS的I/O请求发送到VMM后，VMM需要将这些请求转发到service OS，这无疑增加了上下文的开销。混合模型的代表有[Xen](https://link.zhihu.com/?target=https%3A//xenproject.org/)，Intel最近推出的[Acrn](https://link.zhihu.com/?target=https%3A//projectacrn.org/)，以及我国工程师写的[minos](https://link.zhihu.com/?target=https%3A//github.com/minos-project/minos-hypervisor)。

上面介绍的这三种VMM实现模型和全虚拟化/类虚拟化的guest VM之间并没有直接的对应关系，比如Xen就既可以支持类虚拟化的guest VM，也可以支持全虚拟化的guest VM。还有一种划分方法是将VMM分为基于bare-metal的**type-1**和基于OS的**type-2**，从这个角度划分的话，hypervisor模型和混合模型都是属于type-1的，host模型则是属于type-2的【1】。

[下文](https://zhuanlan.zhihu.com/p/74478035)将介绍这几种虚拟化技术在x86和ARM平台上的具体实现。

注【1】：这里区分两个名词 - hypervisor和VMM，hypervisor通常仅用于表达type-1的VMM，所以在接下来的《虚拟化技术》系列文章中，除非是仅讨论Xen/Acrn这种确定的type-1的虚拟化平台时，才会使用hypervisor一词，其他时候都统一称为VMM。

![虚拟化技术 - 概览（二）](https://pic4.zhimg.com/v2-1d3ccce7fd1635da4d3276971c9fd6d2_1200x500.jpg)

# 虚拟化技术 - 概览（二）

[![兰新宇](https://pic4.zhimg.com/da8e974dc_xs.jpg)](https://www.zhihu.com/people/lan-xin-yu)

[兰新宇](https://www.zhihu.com/people/lan-xin-yu)

talk is cheap

8 人赞同了该文章

[上文](https://zhuanlan.zhihu.com/p/69629212)介绍了常用的几种虚拟化平台，本文将阐述这些平台在x86和ARM上的具体实现。

**KVM/Xen for x86**

传统的x86架构的运行级别有4种，从**ring 0**到**ring 3**，ring 0是最高特权级，通常用于操作系统内核，ring 3是最低特权级，通常用于用户程序。ring 1最初本来被设定为运行驱动程序，但在使用宏内核的linux中，驱动程序也和内核一样运行于ring 0级别，因而ring 1和ring 2通常并不被使用。

![img](https://pic1.zhimg.com/80/v2-564f852ef564e19a55300b71832ba3b4_hd.jpg)

而后x86开始从硬件上支持虚拟化扩展，也就是上文提到的VMM，按理VMM运行的特权级别应该比OS更高，可是OS已经是ring 0了，可以想到的常规解决办法有2个：

1. 将OS的运行级别调到ring1，像这样：

![img](https://pic1.zhimg.com/80/v2-439828e03a3ffe8c5284798bd8a226b0_hd.jpg)

因为之前操作系统的实现都是基于ring 0的，调到ring 1势必会造成很多的不兼容性，需要进行的OS代码改动量较大。

\2. 增加一个ring -1的级别给VMM用。你说要是x86最开始把ring 3设为最高级，ring 0设为最低级，那直接弄个ring 4给VMM就可以了，可x86诞生之初怎么会预料到后来的虚拟化扩展呢。不过这使用负数的ring -1怎么看都觉得别扭吧。

![img](https://pic4.zhimg.com/80/v2-1cc2c17bb03965d0b083a9ae63855c5f_hd.jpg)

为了解决这个难题，x86采用的办法是增加一个root mode，原理大概是这样的：

![img](https://pic1.zhimg.com/80/v2-f6c2afbf034ebd44b0230f9a5c9e6fe0_hd.jpg)

对于Xen/Acrn来说这没有问题，但对于KVM这种基于host OS的，如果只有host OS运行于root mode，host上的Apps（userspace）运行在non-root mode的ring 3级别，那么从host userspace到host kernel的切换就和guest VM向VMM的切换一样了。所以，最终的实现是root mode里也有ring 0到ring 3共4个级别，也就是说root mode和ring是正交的关系。

![img](https://pic2.zhimg.com/80/v2-46002ac730cd5e8f391aaa0ec961e699_hd.jpg)

对于KVM，其基于的host OS（也就是linux内核）运行在root mode的ring 0级别，host userspace运行在root mode的ring 3级别，还是ring 0和ring 3，和linux的传统用法一样，因而对linux来说不用做什么大的修改。guest OS和guest Apps则分别运行在not-root mode的ring 0和ring 3级别。

对于Xen/Acrn，VMM/hypervisor运行在root mode的ring 0级别，root mode的ring 3级别未被使用，所有的VM（对于Xen是分为Dom0和Dom1, ..., DomN，对于Acrn是分为service OS和user OS）都运行在not-root mode。

**KVM/Xen for ARM**

在ARMv6及更早期的架构中，一共支持USR, IRQ, FIQ, ABT, SVC, SYS, UND七种工作模式，除了USR以外，其他都是特权模式，USR模式等同于x86的ring 3，其他六种模式基本等同于x86的ring 0。从ARMv7开始，逐渐支持虚拟化扩展，增加了一种hypervisor模式。到了ARMv8时代，出现了Exceptional Level的概念，OS位于EL1，hypervisor位于EL2。

![img](https://pic2.zhimg.com/80/v2-31bdb876408edfdd5410b4b280d36285_hd.jpg)

Acrn目前还没有提供对ARM的支持（毕竟牙膏厂做这个就是为了卖他们自家的芯片的），这里就不讨论了。对于Xen，直接就是跑在EL2，移植比较方便。但是对于KVM，问题就比较复杂了。因为KVM是基于linux的，在ARMv8的这套架构里，linux应该跑在EL1，如果要使用硬件提供的hypervisor功能，就要把linux移到EL2，这需要对linux源码做大量的修改，现在的方案应该是一部分跑在EL1，一部分跑在EL2，关于这个问题的深入讨论请参考[这篇文章](https://link.zhihu.com/?target=https%3A//lwn.net/Articles/557132/)。