# NoSQL



## NoSQL简介 <a id="NoSQL&#x7B80;&#x4ECB;"></a>

### NoSQL概念: <a id="NoSQL&#x6982;&#x5FF5;"></a>

![NoSQL&#x6982;&#x5FF5;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL%E6%A6%82%E5%BF%B5.png)

图；NoSQL概念的演变

NoSQL最初表示的“反SQL”运动，用新型的非关系型数据库取代关系型数据库。

现在NoSQL（Not only SQL）表示关系和非关系型数据库各有优缺点，彼此都无法互相取代。

### NoSQL的特点： <a id="NoSQL&#x7684;&#x7279;&#x70B9;&#xFF1A;"></a>

通常，NoSQL数据库具有以下几个特点：

1. 灵活的可扩展性。
2. 灵活的数据模型
3. 与云计算紧密融合。

现在有很多公司都使用了NoSQL数据库：如Google，Facebook，百度，阿里等。

## NoSQL兴起的原因 <a id="NoSQL&#x5174;&#x8D77;&#x7684;&#x539F;&#x56E0;"></a>

### 原因一：关系型数据库已经无法满足Web2.0的需求 <a id="&#x539F;&#x56E0;&#x4E00;&#xFF1A;&#x5173;&#x7CFB;&#x578B;&#x6570;&#x636E;&#x5E93;&#x5DF2;&#x7ECF;&#x65E0;&#x6CD5;&#x6EE1;&#x8DB3;Web2-0&#x7684;&#x9700;&#x6C42;"></a>

关系型数据库无法满足Web2.0的需求，主要表现在以下几个方面：

1. 无法满足海量数据的管理需求。
2. 无法满足数据高并发的需求。
3. 无法满足高可扩展性和高可用性的需求。

在现在**1分钟**的时间内：

* 新浪可以发送2万条微博。
* 苹果可以下载4.7万次应用。
* 淘宝可以卖出6万件商品。
* 人人网可以发送30万次访问。
* 百度可以产生90万次搜索查询。

#### MySQL集群是否可以完全解决问题？ <a id="MySQL&#x96C6;&#x7FA4;&#x662F;&#x5426;&#x53EF;&#x4EE5;&#x5B8C;&#x5168;&#x89E3;&#x51B3;&#x95EE;&#x9898;&#xFF1F;"></a>

* 复杂性：部署、管理、配置很复杂。
* 数据库复制：MySQL主备之间采用复制方式，只能是异步复制，当主库压力较大时可能产生较大延迟，主备切换可能会丢失最后一部分更新事务，这时往往需要人工介入，备份和恢复不方便。
* 扩容问题：如果系统压力过大需要增加新的机器，这个过程涉及数据重新划分，整个过程比较复杂，且容易出错。
* 动态数据迁移问题：如果某个数据库组压力过大，需要将其中部分数据迁移出去，迁移过程需要总控节点整体协调，以及数据库节点的配合。这个过程很难做到自动化。

### 原因二：“One size fits all”模式很难适用于截然不同的业务场景： <a id="&#x539F;&#x56E0;&#x4E8C;&#xFF1A;&#x201C;One-size-fits-all&#x201D;&#x6A21;&#x5F0F;&#x5F88;&#x96BE;&#x9002;&#x7528;&#x4E8E;&#x622A;&#x7136;&#x4E0D;&#x540C;&#x7684;&#x4E1A;&#x52A1;&#x573A;&#x666F;&#xFF1A;"></a>

* 关系模型作为统一的数据模型既被用于数据分析，也被用于在线业务。但这两者一个强调高吞吐，一个强调低延时，已经演化出完全不同的架构。用同一套模型来抽象显然是不合适的。
* Hadoop就是针对数据分析。
* MongoDB、Redis等是针对在线业务，两者都抛弃了关系模型。

### 原因三：关系型数据库的关键特性： <a id="&#x539F;&#x56E0;&#x4E09;&#xFF1A;&#x5173;&#x7CFB;&#x578B;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5173;&#x952E;&#x7279;&#x6027;&#xFF1A;"></a>

关系数据库的关键特性包括完善的**事务机制**和**高效的查询机制**。但是，关系数据库引以为傲的两个关键特性，到了Web2.0时代却成了鸡肋，主要表现在以下几个方面：

1. Web2.0网站系统通常不要求严格的数据库事务。
2. Web2.0并不要求严格的读写实时性。
3. Web2.0通常不包含大量复杂的SQL查询（去结构化，存储空间换取更好的查询性能）。

## NoSQL与关系型数据库的比较 <a id="NoSQL&#x4E0E;&#x5173;&#x7CFB;&#x578B;&#x6570;&#x636E;&#x5E93;&#x7684;&#x6BD4;&#x8F83;"></a>

### NoSQL和关系数据库的简单比较： <a id="NoSQL&#x548C;&#x5173;&#x7CFB;&#x6570;&#x636E;&#x5E93;&#x7684;&#x7B80;&#x5355;&#x6BD4;&#x8F83;&#xFF1A;"></a>

> RDBMS即关系数据库管理系统\(Relational Database Management System\)。

![&#x6BD4;&#x8F83;1](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%AF%94%E8%BE%831.png)

![&#x6BD4;&#x8F83;2](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%AF%94%E8%BE%832.png)

![&#x6BD4;&#x8F83;3](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%AF%94%E8%BE%833.png)

### 对比总结： <a id="&#x5BF9;&#x6BD4;&#x603B;&#x7ED3;&#xFF1A;"></a>

**关系数据库：**

* 优势：以完善的关系代数理论作为基础，有严格的标准，支持事务ACID四性，借助索引机制可以实现高效的查询，技术成熟，有专业公司的技术支持 。
* 劣势：可扩展性较差，无法较好支持海量数据存储，数据模型过于死板、无法较好支持Web2.0应用，事务机制影响了系统的整体性能等。

**NoSQL数据库：**

* 优势：可以支持超大规模数据存储，灵活的数据模型可以很好地支持Web2.0应用，具有强大的横向扩展能力等 。
* 劣势：缺乏数学理论基础，复杂查询性能不高，大都不能实现事务强一致性，很难实现数据完整性，技术尚不成熟，缺乏专业团队的技术支持，维护较困难等。

**关系数据库和NoSQL数据库各有优缺点，彼此无法取代。**

* 关系数据库应用场景：电信、银行等领域的关键业务系统，需要保证强事务一致性。
* NoSQL数据库应用场景：互联网企业、传统企业的非关键业务（比如数据分析）。

  **采用混合架构**：

* 案例：亚马逊公司就使用不同类型的数据库来支撑它的电子商务应用。
* 对于“购物篮”这种临时性数据，采用键值存储会更加高效。
* 当前的产品和订单信息则适合存放在关系数据库中。
* 大量的历史订单信息则适合保存在类似MongoDB的文档数据库中。

## NoSQL的四大类型 <a id="NoSQL&#x7684;&#x56DB;&#x5927;&#x7C7B;&#x578B;"></a>

### 四大类： <a id="&#x56DB;&#x5927;&#x7C7B;&#xFF1A;"></a>

NoSQL数据库虽然数量众多，但是，归结起来，典型的NoSQL数据库通常包括**键值数据库、列族数据库、文档数据库和图形数据库。**

![&#x952E;&#x503C;&#x6570;&#x636E;&#x5E93;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93.png)

### 图:键值数据库示例 <a id="&#x56FE;-&#x952E;&#x503C;&#x6570;&#x636E;&#x5E93;&#x793A;&#x4F8B;"></a>

![&#x5217;&#x65CF;&#x6570;&#x636E;&#x5E93;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E6%97%8F%E6%95%B0%E6%8D%AE%E5%BA%93.png)

### 图：列族数据库 <a id="&#x56FE;&#xFF1A;&#x5217;&#x65CF;&#x6570;&#x636E;&#x5E93;"></a>

![&#x6587;&#x6863;&#x6570;&#x636E;&#x5E93;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93.png)

### 图：文档数据库 <a id="&#x56FE;&#xFF1A;&#x6587;&#x6863;&#x6570;&#x636E;&#x5E93;"></a>

![&#x56FE;&#x5F62;&#x6570;&#x636E;&#x5E93;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93.png)

### 图：图形数据库 <a id="&#x56FE;&#xFF1A;&#x56FE;&#x5F62;&#x6570;&#x636E;&#x5E93;"></a>

四大数据库的主要产品：

![&#x56DB;&#x5927;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9B%9B%E5%A4%A7.png)

图：四大数据库的主要产品

### 键值数据库： <a id="&#x952E;&#x503C;&#x6570;&#x636E;&#x5E93;&#xFF1A;"></a>

相关产品：

* Redis、Riak、SimpleDB、Chordless、Scalaris、Memcached。

数据模型：

* 键/值对
* 键是一个字符串对象
* 值可以是任意类型的数据，比如整型、字符型、数组、列表、集合等。

典型应用：

* 涉及频繁读写、拥有简单数据模型的应用
* 内容缓存，比如会话、配置文件、参数、购物车等
* 存储配置和用户数据信息的移动应用

优点：

* 扩展性好
* 灵活性好
* 大量写操作时性能高

缺点：

* 无法存储结构化信息，条件查询效率较低

不适用情形：

* 不是通过键而是通过值来查：键值数据库根本没有通过值查询的途径。
* 需要存储数据之间的关系：在键值数据库中，不能通过两个或两个以上的键来关联数据。
* 需要事务的支持：在一些键值数据库中，产生故障时，不可以回滚。

使用者：

* 百度云数据库（Redis）、GitHub（Riak）、BestBuy（Riak）、Twitter（Redis和Memcached）、StackOverFlow（Redis）、Instagram （Redis）、Youtube（Memcached）、Wikipedia（Memcached）

![&#x7F13;&#x5B58;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98.png)

图：键值数据库成为理想的缓冲层解决方案

Redis有时候会被人们称为“强化版的Memcached” 支持持久化、数据恢复、更多数据类型.

### 列族数据库： <a id="&#x5217;&#x65CF;&#x6570;&#x636E;&#x5E93;&#xFF1A;"></a>

相关产品：

* BigTable、HBase、Cassandra、HadoopDB、GreenPlum、PNUTS

数据模型：列族

典型应用：

* 分布式数据存储与管理
* 数据在地理上分布于多个数据中心的应用程序
* 可以容忍副本中存在短期不一致情况的应用程序
* 拥有动态字段的应用程序
* 拥有潜在大量数据的应用程序，大到几百TB的数据

优点：

* 查找速度快
* 可扩展性强
* 容易进行分布式扩展
* 复杂性低

缺点：

* 功能较少，大都不支持强事务一致性。

不适用情形：

* 需要ACID事务支持的情形，Cassandra等产品就不适用

使用者：

* Ebay（Cassandra）、Instagram（Cassandra）、NASA（Cassandra）、Twitter（Cassandra and HBase）、Facebook（HBase）、Yahoo!（HBase）

### 文档数据库： <a id="&#x6587;&#x6863;&#x6570;&#x636E;&#x5E93;&#xFF1A;"></a>

“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行“自我描述”。XML文档、HTML文档和JSON 文档就属于这一类。SequoiaDB就是使用JSON格式的文档数据库，它的存储的数据是这样的：

![&#x6587;&#x6863;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3.png)

图：文档数据库示例

文档数据库的特点：

* 数据是不规则的，每一条记录包含了所有的有关“SequoiaDB”的信息而没有任何外部的引用，这条记录就是“自包含”的。
* 这使得记录很容易完全移动到其他服务器，因为这条记录的所有信息都包含在里面了，不需要考虑还有信息在别的表没有一起迁移走。
* 同时，因为在移动过程中，只有被移动的那一条记录（文档）需要操作，而不像关系型中每个有关联的表都需要锁住来保证一致性，这样一来ACID的保证就会变得更快速，读写的速度也会有很大的提升。

文档数据库的相关产品：

* MongoDB、CouchDB、Terrastore、ThruDB、RavenDB、SisoDB、RaptorDB、CloudKit、Perservere、Jackrabbit

数据模型：

* 键/值
* 值（value）是版本化的文档

典型应用：

* 存储、索引并管理面向文档的数据或者类似的半结构化数据。
* 比如，用于后台具有大量读写操作的网站、使用JSON数据结构的应用、使用嵌套结构等非规范化数据的应用程序。

优点：

* 性能好（高并发），灵活性高，复杂性低，数据结构灵活。
* 提供嵌入式文档功能，将经常查询的数据存储在同一个文档中。
* 既可以根据键来构建索引，也可以根据内容构建索引

缺点：缺乏统一的查询语法。

不适用情形：

* 在不同的文档上添加事务。文档数据库并不支持文档间的事务，如果对这方面有需求，则不应该选用这个解决方案。

使用者：

* 百度云数据库（MongoDB）、SAP （MongoDB）、Codecademy （MongoDB）、Foursquare （MongoDB）、NBC News （RavenDB）

### 图形数据库： <a id="&#x56FE;&#x5F62;&#x6570;&#x636E;&#x5E93;&#xFF1A;"></a>

相关产品：

* Neo4J、OrientDB、InfoGrid、Infinite Graph、GraphDB

数据模型：图结构

典型应用：

* 专门用于处理具有高度相互关联关系的数据，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题

优点：

* 灵活性高，支持复杂的图形算法，可用于构建复杂的关系图谱。

缺点：复杂性高，只能支持一定的数据规模。

使用者：

* Adobe（Neo4J）、Cisco（Neo4J）、T-Mobile（Neo4J）

### 不同类型数据库比较分析； <a id="&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x6570;&#x636E;&#x5E93;&#x6BD4;&#x8F83;&#x5206;&#x6790;&#xFF1B;"></a>

![&#x6570;&#x636E;&#x5E93;&#x6BD4;&#x8F83;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83.png)

MySQL产生年代较早，而且随着（Web应用软件组合）LAMP（Linux+Apache+Mysql/MariaDB+Perl/PHP/Python）大潮得以成熟。尽管其没有什么大的改进，但是新兴的互联网使用的最多的数据库。

MongoDB是个新生事物，提供更灵活的数据模型、异步提交、地理位置索引等五花十色的功能。

HBase是个“仗势欺人”的大象兵。依仗着Hadoop的生态环境，可以有很好的扩展性。但是就像象兵一样，使用者需要养一头大象\(Hadoop\),才能驱使他。

Redis是键值存储的代表，功能最简单。提供随机数据存储。就像一根棒子一样，没有多余的构造。但是也正是因此，它的伸缩性特别好。就像悟空手里的金箍棒，大可捅破天，小能成缩成针。

## NoSQL的三大基石 <a id="NoSQL&#x7684;&#x4E09;&#x5927;&#x57FA;&#x77F3;"></a>

> 三大基石：CAP，BASE，最终一致性。

### CAP： <a id="CAP&#xFF1A;"></a>

所谓的CAP指的是：

* **C（Consistency）：一致性**，是指任何一个读操作总是能够读到之前完成的写操作的结果，也就是在分布式环境中，多点的数据是一致的，或者说，所有节点在同一时间具有相同的数据。
* **A:（Availability）：可用性**，是指快速获取数据，可以在确定的时间内返回操作结果，保证每个请求不管成功或者失败都有响应；
* **P（Tolerance of Network Partition）：分区容忍性**，是指当出现网络分区的情况时（即系统中的一部分节点无法和其他节点进行通信），分离的系统也能够正常运行，也就是说，系统中任意信息的丢失或失败不会影响系统的继续运作。

![cap](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/cap.png)

图：CAP Theorem\(理论\)

CAP理论告诉我们，一个分布式系统不可能同时满足一致性、可用性和分区容忍性这三个需求，最多只能同时满足其中两个，正所谓“鱼和熊掌不可兼得”。

当处理CAP的问题时，可以有几个明显的选择：

1. CA：也就是强调一致性（C）和可用性（A），放弃分区容忍性（P），最简单的做法是把所有与事务相关的内容都放到同一台机器上。很显然，这种做法会严重影响系统的可扩展性。传统的关系数据库（MySQL、SQL Server和PostgreSQL），都采用了这种设计原则，因此，扩展性都比较差
2. CP：也就是强调一致性（C）和分区容忍性（P），放弃可用性（A），当出现网络分区的情况时，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务
3. AP：也就是强调可用性（A）和分区容忍性（P），放弃一致性（C），允许系统返回不一致的数据

![CAP&#x9009;&#x62E9;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/CAP%E9%80%89%E6%8B%A9.png)

图：不同产品在CAP理论下的不同设计原则

### BASE: <a id="BASE"></a>

说起BASE（Basically Availble, Soft-state, Eventual consistency），不得不谈到ACID。

![ACID](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/ACID.png)

**一个数据库事务具有ACID四性：**

* A（Atomicity）：原子性，是指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行。
* C（Consistency）：一致性，是指事务在完成时，必须使所有的数据都保持一致状态。
* I（Isolation）：隔离性，是指由并发事务所做的修改必须与任何其它并发事务所做的修改隔离。
* D（Durability）：持久性，是指事务完成之后，它对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持。

BASE的基本含义是基本可用（Basically Availble）、软状态（Soft-state）和最终一致性（Eventual consistency）：

**基本可用：**

基本可用，是指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用，也就是允许分区失败的情形出现。

**软状态：**

“软状态（soft-state）”是与“硬状态（hard-state）”相对应的一种提法。数据库保存的数据是“硬状态”时，可以保证数据一致性，即保证数据一直是正确的。“软状态”是指状态可以有一段时间不同步，具有一定的滞后性。

**最终一致性：**

​ 一致性的类型包括**强一致性和弱一致性**，二者的主要区别在于高并发的数据访问操作下，后续操作是否能够获取最新的数据。对于强一致性而言，当执行完一次更新操作后，后续的其他读操作就可以保证读到更新后的最新数据；反之，如果不能保证后续访问读到的都是更新后的最新数据，那么就是弱一致性。而最终一致性只不过是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但是经过一段时间之后，必须最终读到更新后的数据。

​ 最常见的实现最终一致性的系统是DNS（域名系统）。一个域名更新操作根据配置的形式被分发出去，并结合有过期机制的缓存；最终所有的客户端可以看到最新的值。

最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：

* 因果一致性：如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将获得A写入的最新值。而与进程A无因果关系的进程C的访问，仍然遵守一般的最终一致性规则。
* “读己之所写”一致性：可以视为因果一致性的一个特例。当进程A自己执行一个更新操作之后，它自己总是可以访问到更新过的值，绝不会看到旧值。
* 单调读一致性：如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。
* 会话一致性：它把访问存储系统的进程放到会话（session）的上下文中，只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统保证不会延续到新的会话。
* 单调写一致性：系统保证来自同一个进程的写操作顺序执行。系统必须保证这种程度的一致性，否则就非常难以编程了。

**如何实现各种类型的一致性？**

对于分布式数据系统：

* N — 数据复制的份数
* W — 更新数据是需要保证写完成的节点数
* R — 读取数据的时候需要读取的节点数

  如果W+R&gt;N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。一般设定是R＋W = N+1，这是保证强一致性的最小设定。

  如果W+R&lt;=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。

对于分布式系统，为了保证高可用性，一般设置N&gt;=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。

如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。 实例：HBase是借助其底层的HDFS来实现其数据冗余备份的。HDFS采用的就是强一致性保证。在数据没有完全同步到N个节点前，写操作是不会返回成功的。也就是说它的W＝N，而读操作只需要读到一个值即可，也就是说它R＝1。

像Voldemort，Cassandra和Riak这些类Dynamo的系统，通常都允许用户按需要设置N，R，W三个值，即使是设置成W＋R&lt;= N也是可以的。也就是说他允许用户在强一致性和最终一致性之间自由选择。而在用户选择了最终一致性，或者是W&lt;N的强一致性时，则总会出现一段“各个节点数据不同步导致系统处理不一致的时间”。为了提供最终一致性的支持，这些系统会提供一些工具来使数据更新被最终同步到所有相关节点。

### 从NoSQL到NewSQL数据库 <a id="&#x4ECE;NoSQL&#x5230;NewSQL&#x6570;&#x636E;&#x5E93;"></a>

![No&#x5230;New](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/No%E5%88%B0New.png)

图：大数据引发数据处理架构变革

![&#x6570;&#x636E;&#x636E;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E6%8D%AE.png)

图：关系数据库、NoSQL和NewSQL数据库产品分类图

## 文档数据库MongoDB <a id="&#x6587;&#x6863;&#x6570;&#x636E;&#x5E93;MongoDB"></a>

### MongoDB简介： <a id="MongoDB&#x7B80;&#x4ECB;&#xFF1A;"></a>

MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。

在高负载的情况下，添加更多的节点，可以保证服务器性能。

MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。

MongoDB 将数据存储为一个文档，数据结构由键值\(key=&gt;value\)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

![Mongo](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/Mongo.png)

图：mangoDB示例

### MongoDB主要特点： <a id="MongoDB&#x4E3B;&#x8981;&#x7279;&#x70B9;&#xFF1A;"></a>

* 提供了一个面向文档存储，操作起来比较简单和容易
* 可以设置任何属性的索引来实现更快的排序
* 具有较好的水平可扩展性
* 支持丰富的查询表达式，可轻易查询文档中内嵌的对象及数组
* 可以实现替换完成的文档（数据）或者一些指定的数据字段
* MongoDB中的Map/Reduce主要是用来对数据进行批量处理和聚合操作
* 支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C\#等语言
* MongoDB安装简单

### MongoDB概念解析： <a id="MongoDB&#x6982;&#x5FF5;&#x89E3;&#x6790;&#xFF1A;"></a>

在mongodb中基本的概念是**文档、集合、数据库**。

![&#x6982;&#x5FF5;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E5%BF%B5.png)

通过下图实例，我们也可以更直观的的了解MongoDB中的一些概念：

![&#x793A;&#x4F8B;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%A4%BA%E4%BE%8B.png)

图：关系数据库和MongoDB的示例

举例2：在一个关系型数据库中，一篇博客（包含文章内容、评论、评论的投票）会被打散在多张数据表中。在文档数据库MongoDB中，能用一个文档来表示一篇博客， 评论与投票作为文档数组，放在正文主文档中。这样数据更易于管理，消除了传统关系型数据库中影响性能和水平扩展性的“JOIN”操作。

**数据库**

* 一个mongodb中可以建立多个数据库。
* MongoDB的默认数据库为”db”，该数据库存储在data目录中。
* MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。

**文档**  
文档是一个键值\(key-value\)对\(即BSON\)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。  
一个简单的文档例子如下：复制

|  |  |
| :--- | :--- |


**RDBMS与MongoDB对应术语：**

![&#x5BF9;&#x5E94;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%B9%E5%BA%94.png)

**集合**

集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System\)中的表格。

集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。 比如，我们可以将以下不同数据结构的文档插入到集合中：复制

|  |  |
| :--- | :--- |


**MongoDB数据类型：**

![&#x6570;&#x636E;&#x7C7B;&#x578B;](https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

> 以上

